# --- Server schema ---

schema {
  # The query root of Teams' GraphQL interface.
  query: Query
  mutation: Mutation
  subscription: Subscription
}

type Query {
  # @param userId - user ID
  # @return - presence of user with given ID
  presence(userId: ID!): Presence
  # @param userId - user ID
  # @return - user with given ID
  user(userId: ID!): User
  # @return - current user
  currentUser: User
  # @param channelId - Channel ID
  # @param teamId - Team ID
  # @return - reply chains
  replyChains(teamId: ID!, channelId: ID!): [ReplyChains]
  # @param filter - filter to filter the users by
  # @return - list of users having a display name or upn containing the filter provided
  users(filter: String): [User]
  # @param convId - conversation ID to search by
  # @return - list of messages within the conversaton having the provided ID
  messages(convId: ID!): [Message]
  # @return - list of all 1:1 conversations for the current user
  chats: [Conversation]
  # @param convId - conversation ID to search by
  # @return - 1:1 conversaton having the provided ID
  chat(convId: ID!): Conversation
  # @param userId - user ID to search by
  # @return - 1:1 conversation having only 2 members; one of which is the provided user
  chatWithUser(userId: ID!): Conversation
  # @param userEmail - user email to get profile picture for
  # @param displayNames - display names to get profile picture for
  # @return - blob url of the retrieved picture
  profilePicture(userEmails: [String]!, displayNames: [String]!): Blob
  # @param startDate - Start Date to fetch the events from
  # @param endDate - End Date to fetch the events upto
  # @param scenarioName - Current Active Scenario Nane
  # @return - list of calendar events
  calendarEvents(
    startDate: String!
    endDate: String!
    scenarioName: String!
  ): [CalendarEvent]
  # @param eventId - Event Id of calendar event
  # @return - entire calendar event for the eventId
  calendarEvent(eventId: String!): CalendarEvent
  # @return - unread notification and chat counts
  unreadCounts: UnreadCounts
  # @return - list of all teams for the current user
  teams: [Team]
  # @return - list of all the buildings in the current tenant
  buildings: [Building]
  # @param buildingAddressFilter - email address of the building to fetch the rooms for
  # @return - list of all the rooms inside building using the building address
  rooms(buildingAddressFilter: String!): [Room]
  # @param url - URL to get the preview of
  # @return - Url Preview
  urlPreview(url: String!): UrlPreview
}

type Mutation {
  # @param presence - presence to set
  # @return - updated presence
  setPresence(presence: String!): Presence
  # @param userId - user ID
  # @return - id of user subscribed
  subscribePresence(userId: ID!): SubscriptionResult
  # @param userId - user ID
  # @return - id of user subscribed
  unsubscribePresence(userId: ID!): SubscriptionResult
  # @param convId - conversation ID to attach the message to
  # @param text - text of the message
  # @param messageType - "Text" or "RichText/Html"
  # @param urlPreview - The UrlPreview to include with the message
  # @return - message sent having the provided ID
  sendMessage(
    convId: ID!
    text: String!
    messageType: String
    urlPreview: UrlPreviewInput
    mentions: [MentionInput]
  ): Message
  # @param userId - user ID to start the conversation with
  # @param text - text of the message
  # @param messageType - "text" or "RichText/Html"
  # @return - 1:1 conversaton having the provided ID
  sendMessageToUser(
    userId: ID!
    text: String!
    messageType: String
  ): Conversation
  # @param calendarEvent - calendar event object send to MT
  # @return - newely created or updated calendar event
  createOrUpdateCalendarEvent(calendarEvent: CalendarEventInput): CalendarEvent
  # @param convId - conversation ID
  # @param members - an array of user-id/role tuples for members to be added to the conversation
  # @param shareHistoryTime - how much conversation history (in days) to share if any
  addMembersToConversation(
    convId: ID!
    members: [UserInput!]
    shareHistoryTime: Int
  ): [User!]
}

type ReplyChains {
  containerId: String,
  id: ID!,
  latestDeliveryTime: String,
  messages: [Message]
}

type Blob {
  blobUrl: String
}

# mri
type SubscriptionResult {
  id: ID
}

type NewMessage {
  message: Message!
  convId: ID!
  threadType: String
  threadTopic: String
}

type MessageUpdate {
  message: Message!
}

type ThreadUpdate {
  conversation: Conversation!
}

type ConversationUpdate {
  conversation: Conversation!
}

union ChatServiceEvent =
    NewMessage
  | MessageUpdate
  | ThreadUpdate
  | ConversationUpdate

# endpointId post active event was sent from
type PostActiveResult {
  endpointId: String
}

type Subscription {
  chatServiceEvent: ChatServiceEvent!
  presencePostActiveEvent: PostActiveResult
  presenceSyncEvent: [Presence]
}

enum Availability {
  PresenceUnknown
  Available
  AvailableIdle
  Away
  Busy
  BusyIdle
  DoNotDisturb
  BeRightBack
  Offline
}

# Set by unified presence server
enum Activity {
  InACall
  InAConferenceCall
  InAMeeting
  Presenting
  OffWork
  Available
  Inactive
  Busy
  DoNotDisturb
  BeRightBack
  Away
  Offline
  UrgentInterruptionsOnly
  PresenceUnknown
  OutOfOffice
}

type Presence {
  id: ID
  availability: Availability
  activity: Activity
}

type Conversation {
  id: ID!
  title: String
  isOneOnOne: Boolean!
  lastMessage: Message
  members: [User]
  isHighImportance: Boolean
  isMuted: Boolean
  isLastMessageFromMe: Boolean
  activeCallsCount: Boolean
  datatid: Boolean
  displayName: Boolean
  hasActiveCalls: Boolean
  hasFailedMessages: Boolean
  otherMemberMris: Boolean
  isSfB: Boolean
  isNewChat: Boolean
  isBotBlocked: Boolean
  isBotUser: Boolean
  isFederated: Boolean
  isHidden: Boolean
  pictureUpn: Boolean
  pinnedIndex: Boolean
  showAtMention: Boolean
  showMarkers: Boolean
  tooltipTitle: Boolean
  longTitle: Boolean
  pictureGroup: Boolean
  lastMessageTime: Boolean
  messagePreview: Boolean
  messagePreviewAria: Boolean
  isLastMessageText: Boolean
  isMeeting: Boolean
  plGroupKey: Boolean
  hasActions: Boolean
  canBeDiscarded: Boolean
  canBotBeBlocked: Boolean
  canBePinned: Boolean
  canBeMuted: Boolean
  canBeLeft: Boolean
  canBeHidden: Boolean
  canBeFavorited: Boolean
  pinnedButtonText: Boolean
  pinnedIconSrc: Boolean
  favoriteButtonText: Boolean
  favoriteIconSrc: Boolean
  discardButtonText: Boolean
  muteButtonText: Boolean
  muteIconSrc: Boolean
  blockButtonText: Boolean
  hideButtonText: Boolean
  hideIconSrc: Boolean
  leaveButtonText: Boolean
}

type EmotionUser {
  id: ID!
  time: Int
  value: String
}

type Emotion {
  key: String
  users: [EmotionUser]
}

type Message {
  id: ID
  content: String
  originalArrivalTime: String
  imDisplayName: String
  from: ID
  messageType: String
  contentType: String
  activityType: String
  clientMessageId: String
  isImportant: Boolean
  emotions: [Emotion]

  type: String
  composeTime: String
  containerId: String
  parentMessageId: String
  version: Int
  threadType: String
}

type User {
  id: ID!
  displayName: String
  email: String
  department: String
  givenName: String
  isEnabled: Boolean
  isMuted: Boolean
  jobTitle: String
  mail: String
  mobile: String
  role: String
  physicalDeliveryOfficeName: String
  sipProxyAddress: String
  surname: String
  telephoneNumber: String
  type: String
  userSubType: String
  userPrincipalName: String
  userType: String
}

input UserInput {
  id: ID!
  role: String
}

type CalendarEvent {
  objectId: ID!
  objectUrl: String
  startTime: String!
  endTime: String!
  eventTimeZone: String
  utcOffset: Float
  iCalUID: String
  eventType: AppointmentType
  subject: String
  location: String
  skypeTeamsData: String
  schedulingServiceUpdateUrl: String
  skypeTeamsMeetingUrl: String
  isOnlineMeeting: Boolean
  joinOnlineMeetingUrl: String
  joinMeetingLabel: String
  emptyBodyPlaceholder: String
  myResponseType: MeetingResponseType
  isAllDayEvent: Boolean
  organizerName: String
  organizerAddress: String
  categories: [String]
  isCancelled: Boolean
  isResponseRequested: Boolean
  attendees: [Attendee]
  isReminderSet: Boolean
  reminderMinutesBeforeStart: Int
  mailboxAddress: String
  showAs: FreeBusyType
  isPrivate: Boolean
  bodyContentType: String
  bodyContent: String
  recurrencePattern: String
  recurrenceEnd: String
  isOrganizer: Boolean
  parentConversationId: String
  isAppointment: Boolean
  eventRecurrenceRange: RecurrenceRange
  eventRecurrencePattern: RecurrencePattern
  reminderTime: String
  attachments: [Attachment]
  conflictingMeetings: [CalendarEvent]
  putAnonymousInLobby: Boolean
  eTag: String
}

type Room {
  name: String!
  address: String!
}

type Building {
  name: String!
  address: String!
}

input CalendarEventInput {
  objectId: ID
  objectUrl: String
  startTime: String!
  endTime: String!
  eventTimeZone: String
  utcOffset: Float
  iCalUID: String
  eventType: AppointmentType
  subject: String
  location: String
  skypeTeamsData: String
  schedulingServiceUpdateUrl: String
  skypeTeamsMeetingUrl: String
  isOnlineMeeting: Boolean
  joinOnlineMeetingUrl: String
  joinMeetingLabel: String
  emptyBodyPlaceholder: String
  myResponseType: MeetingResponseType
  isAllDayEvent: Boolean
  organizerName: String
  organizerAddress: String
  categories: [String]
  isCancelled: Boolean
  isResponseRequested: Boolean
  attendees: [AttendeeInput] = []
  isReminderSet: Boolean
  reminderMinutesBeforeStart: Int
  mailboxAddress: String
  showAs: FreeBusyType = Busy
  isPrivate: Boolean
  bodyContentType: String
  bodyContent: String
  recurrencePattern: String
  recurrenceEnd: String
  isOrganizer: Boolean
  parentConversationId: String
  isAppointment: Boolean
  eventRecurrenceRange: RecurrenceRangeInput
  eventRecurrencePattern: RecurrencePatternInput
  reminderTime: String
  attachments: [AttachmentInput]
  conflictingMeetings: [CalendarEventInput]
  putAnonymousInLobby: Boolean
  eTag: String
}

enum AppointmentType {
  Single
  Occurrence
  Exception
  RecurringMaster
}

enum AttendeeType {
  Required
  Optional
  Resource
  Organizer
  Room
}

enum FreeBusyType {
  Free
  Tentative
  Busy
  Oof
  WorkingElsewhere
  Unknown
}

enum MeetingResponseType {
  None
  Organizer
  Tentative
  Accepted
  Declined
  NotResponded
}

type Attendee {
  status: ResponseStatus
  type: AttendeeType
  address: String
  name: String
  jobTitle: String
  mri: String
  role: String
  broadcastMeetingRole: String
}

type ResponseStatus {
  response: String
  time: String
}

type Attachment {
  id: String!
  name: String
  size: Int!
  contentType: String
  fileName: String
  isInline: Boolean!
  contentId: String
}

type RecurrenceRange {
  startDate: String!
  endDate: String
}

type RecurrencePattern {
  patternType: Int!
}

type UnreadCounts {
  notificationCount: Int!
  chatCount: Int!
}

type Team {
  id: ID!
  displayName: String
  picture: String
  channels: [Channel]
  isDeleted: Boolean
}

type Channel {
  id: ID!
  displayName: String
  description: String
  isDeleted: Boolean
}

type UrlPreview {
  url: String
  title: String
  description: String
  thumbnail: String
  thumbnailMeta: ImageMeta
}

type ImageMeta {
  width: Int!
  height: Int!
}

input AttendeeInput {
  status: ResponseStatusInput
  type: AttendeeType
  address: String
  name: String
  jobTitle: String
  mri: String
  role: String
  broadcastMeetingRole: String
}

input ResponseStatusInput {
  response: String
  time: String
}

input AttachmentInput {
  id: String!
  name: String
  size: Int!
  contentType: String
  fileName: String
  isInline: Boolean!
  contentId: String
}

input RecurrenceRangeInput {
  startDate: String!
  endDate: String
}

input RecurrencePatternInput {
  patternType: Int!
}

input UrlPreviewInput {
  url: String!
  title: String
  description: String
  thumbnail: String
  thumbnailMeta: ImageMetaInput
}

input MentionInput {
  itemId: String!
  mri: String!
  mentionType: String!
  displayName: String!
}

input ImageMetaInput {
  width: Int!
  height: Int!
}
